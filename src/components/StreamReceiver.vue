<script setup>
import { ref, onMounted, onUnmounted } from 'vue'; 
import { SkyWayContext, SkyWayRoom, SkyWayStreamFactory, uuidV4 } from '@skyway-sdk/room';
import GetToken from './SkywayToken.js';
import { toast } from 'vue3-toastify';
import "vue3-toastify/dist/index.css";

// 環境変数 (vite)
const appId = import.meta.env.VITE_SKYWAY_APP_ID;
const secret = import.meta.env.VITE_SKYWAY_SECRET_KEY;
const tokenString = GetToken(appId, secret);// トークン生成 (GetToken の実装が同期か非同期かで await 必要か確認)
const context = { ctx: null, room: null };// SkyWay context & room
// refs / state
const streamArea = ref(null); 
const roomCreated = ref(false);
const roomId = ref(null);
const joining = ref(false);
const joined = ref(false);
const localMember = ref(null);
const errorMessage = ref(''); 
const remoteVideos = ref([]); 
// 退出時に解放するために保持（追加）
const localVideoStream = ref(null); 
const localAudioStream = ref(null); 
const localVideoEl = ref(null); 
const leaving = ref(false); 
// ミュート状態管理（新規追加）
const isAudioMuted = ref(false); 
const isVideoMuted = ref(false); 
// 画面共有状態管理（追加）
const isScreenSharing = ref(false); 
const baseUrl = window.location.href.split('?')[0];
// Publication を保持（publish の戻り値として得られるオブジェクト）
const localVideoPublication = ref(null); 
const localAudioPublication = ref(null);
const enlargedVideo = ref(null);
// 追加: 重複 subscribe 防止用（publication.id を記録）
const subscribedPublicationIds = new Set();
// 追加: ルームイベントのハンドラ参照（退出時に解除するため）
const roomEventHandlers = { onStreamPublished: null };

// ヘルパ: SkyWay stream オブジェクトから MediaStreamTrack を取り出す
const extractTrack = (stream, kind = 'video') => {
  if (!stream) return null;
  // SDK が .track を提供している場合
  if (stream.track && stream.track.kind === kind) return stream.track;
  // SDK が .mediaStream を持つ場合
  if (stream.mediaStream) {
    const tracks = kind === 'audio'
      ? stream.mediaStream.getAudioTracks()
      : stream.mediaStream.getVideoTracks();
    if (tracks && tracks.length) return tracks[0];
  }
  // もし渡されるのが生の MediaStream の場合
  if (typeof stream.getTracks === 'function') {
    const tracks = kind === 'audio' ? stream.getAudioTracks() : stream.getVideoTracks();
    if (tracks && tracks.length) return tracks[0];
  }
  return null;
};

// SkyWay Context 作成
const getContext = async () => {
  try {
    context.ctx = await SkyWayContext.Create(tokenString);
    // トークン更新リマインダ (必要ならここで新規トークンを fetch して差し替える)
    context.ctx.onTokenUpdateReminder.add(async () => {
      // const newToken = await fetchNewToken();
      context.ctx.updateAuthToken(tokenString);
    });
    return context.ctx;
  } catch (e) {
    toast.error('認証失敗: ' + e);
    console.error(e);
  }
};

// ルーム作成
const createRoom = async () => {
  try {
    if (!roomId.value) {
      roomId.value = uuidV4();
    }
    context.room = await SkyWayRoom.FindOrCreate(context.ctx, {
      type: 'sfu',
      name: roomId.value
    });
    roomCreated.value = true;
  } catch (e) {
    toast.error('Room 作成失敗: ' + e);
    console.error(e);
  }
};
// 受信ストリームをDOMへattach（映像/音声対応）
// track の onmute/onunmute で動画の見た目（暗転）を制御
// 受信ストリームをDOMへattach（映像/音声対応）
// attachRemoteStream関数でボタンに固有IDを設定
const attachRemoteStream = (stream, publication) => {
  try {
    if (!streamArea.value) return;

    const hasVideo = !!(stream?.track?.kind === 'video' || (stream.mediaStream && stream.mediaStream.getVideoTracks?.().length));
    const hasAudio = !!(stream?.track?.kind === 'audio' || (stream.mediaStream && stream.mediaStream.getAudioTracks?.().length));

    if (hasVideo) {
      const container = document.createElement('div');
      container.className = 'relative inline-block';

    // 追加: publication id を保持（削除用に使う）映像の枠の削除の他
    if (publication?.id) {
    container.dataset.pubId = publication.id;
     }


      streamArea.value.appendChild(container);

      const el = document.createElement('video');
      el.autoplay = true;
      el.playsInline = true;
      el.className = 'w-96 h-72 object-cover rounded border';
      container.appendChild(el);

      // 拡大ボタンを作成
      const enlargeBtn = document.createElement('button');
      enlargeBtn.innerHTML = '⛶';
      enlargeBtn.className = 'absolute top-2 right-2 bg-black bg-opacity-50 text-white p-1 rounded hover:bg-opacity-70 text-sm';
      
      // より確実なイベント設定
      enlargeBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        enlargeVideo(el);
      });
      
      container.appendChild(enlargeBtn);

      // 要素の関連付けを保存
      el.__container = container;
      el.__enlargeBtn = enlargeBtn;

      stream.attach(el);
      el.play?.().catch(() => {});

      const track = extractTrack(stream, 'video');
      if (track) {
        if (track.enabled === false) {
          el.style.filter = 'brightness(30%)';
        }
        track.onmute = () => {
          el.style.filter = 'brightness(30%)';
        };
        track.onunmute = () => {
          el.style.filter = 'none';
        };
      }

      remoteVideos.value.push(container);
      console.log('[REMOTE] created element', {
        pubId: publication?.id,
        publisherId: publication?.publisher?.id,
        totalContainers: streamArea.value?.querySelectorAll('[data-pub-id]').length
      });
    } else if (hasAudio) {
      const el = document.createElement('audio');
      el.autoplay = true;
      el.controls = false;
      el.style.display = 'none';
      streamArea.value.appendChild(el);
      stream.attach(el);
      el.play?.().catch(() => {});
      remoteVideos.value.push(el);
    }
  } catch (err) {
    console.error('attachRemoteStream failed:', err);
  }
}

// Publication.disable/enable を使ってミュートする関数（優先）
const togglePublicationMute = async (pubRef, isMutedRef) => {
  const pub = pubRef.value;
  if (!pub) return false;
  try {
    const willMute = !isMutedRef.value;
    if (willMute) {
      // mute
      if (typeof pub.disable === 'function') {
        await pub.disable();
        isMutedRef.value = true;
        return true;
      }
    } else {
      // unmute
      if (typeof pub.enable === 'function') {
        await pub.enable();
        isMutedRef.value = false;
        return true;
      }
    }
  } catch (e) {
    console.error('togglePublicationMute error:', e);
    return false;
  }
  return false;
};

// 代替: MediaStreamTrack.enabled を切り替えるフォールバック
const setStreamMutedFallback = (skywayStream, kind, muted) => {
  const track = extractTrack(skywayStream, kind);
  if (!track) {
    console.warn('No track found for fallback mute:', kind, skywayStream);
    return false;
  }
  try {
    track.enabled = !muted;
    return true;
  } catch (e) {
    console.error('setStreamMutedFallback error:', e);
    return false;
  }
};

// 音声ミュート切り替え
const toggleAudioMute = async () => {
  // まず Publication API を試す
  let ok = await togglePublicationMute(localAudioPublication, isAudioMuted);
  if (!ok) {
    // フォールバック: track.enabled を切り替える
    const newMuted = !isAudioMuted.value;
    const fOk = setStreamMutedFallback(localAudioStream.value, 'audio', newMuted);
    if (fOk) isAudioMuted.value = newMuted;
    ok = fOk;
  }
  if (!ok) console.warn('Audio mute/unmute failed (no publication & no track)');
};

// 映像ミュート切り替え（修正版）
const toggleVideoMute = async () => {
  // まず Publication API を試す（togglePublicationMute は isMutedRef を更新する）
  let ok = await togglePublicationMute(localVideoPublication, isVideoMuted);

  // Publication API が使えずフォールバックした場合はここでフラグを反転して更新する
  if (!ok) {
    const newMuted = !isVideoMuted.value;
    const fOk = setStreamMutedFallback(localVideoStream.value, 'video', newMuted);
    if (fOk) {
      isVideoMuted.value = newMuted;
      ok = true;
    }
  }

  // 最終的なフラグ IsVideoMuted.value を参照してローカルの見た目を更新（反転や ! を使わない）
  if (localVideoEl.value) {
    localVideoEl.value.style.filter = isVideoMuted.value ? 'brightness(30%)' : 'none';
  }

  if (!ok) console.warn('Video mute/unmute failed (no publication & no track)');
};
//画面共有
const screenShare = async () => {
  if (!localMember.value) return;
  
  try {
    if (isScreenSharing.value) {
      // 画面共有停止 - 元のカメラ映像に戻す
      await localMember.value.unpublish(localVideoPublication.value);
      // カメラ映像を再作成してpublish
      const cameraStream = await SkyWayStreamFactory.createCameraVideoStream();
      localVideoStream.value = cameraStream;
      localVideoPublication.value = await localMember.value.publish(cameraStream);
      
      // ローカル映像要素を更新
      if (localVideoEl.value) {
        cameraStream.attach(localVideoEl.value);
      }
      
      isScreenSharing.value = false;
    } else {
      // 画面共有開始
      const { video: screenStream } = await SkyWayStreamFactory.createDisplayStreams({
        audio: false,
        video: {
          displaySurface: 'monitor'
        }
      });
      
      // 現在の映像をunpublish
      await localMember.value.unpublish(localVideoPublication.value);
      
      // 画面共有をpublish
      localVideoStream.value = screenStream;
      localVideoPublication.value = await localMember.value.publish(screenStream);
      
      // ローカル映像要素を更新
      if (localVideoEl.value) {
        screenStream.attach(localVideoEl.value);
      }
      
      isScreenSharing.value = true;
    }
  } catch (error) {
    console.error('画面共有エラー:', error);
    toast.value = '画面共有に失敗しました: ' + error.message;
  }
};

// 映像拡大機能
const enlargeVideo = (videoEl) => {
  if (enlargedVideo.value) return;
  
  videoEl.__originalClass = videoEl.className;
  videoEl.__originalParent = videoEl.parentNode;
  videoEl.__originalNextSibling = videoEl.nextSibling; // 元の位置を保存
  
  videoEl.className = 'fixed inset-0 w-screen h-screen object-contain bg-black z-50 cursor-pointer';
  document.body.appendChild(videoEl);
  
  // 閉じるボタンを追加
  const closeBtn = document.createElement('button');
  closeBtn.innerHTML = '✕';
  closeBtn.className = 'fixed top-4 right-4 z-50 bg-red-600 text-white p-3 rounded-full hover:bg-red-700 text-xl font-bold';
  closeBtn.onclick = (e) => {
    e.stopPropagation();
    shrinkVideo();
  };
  document.body.appendChild(closeBtn);
  
  // 映像をクリックで閉じる
  videoEl.onclick = shrinkVideo;
  
  videoEl.__closeBtn = closeBtn;
  enlargedVideo.value = videoEl;
};

// shrinkVideo関数を以下のように修正
const shrinkVideo = () => {
  if (!enlargedVideo.value) return;
  
  const videoEl = enlargedVideo.value;
  videoEl.className = videoEl.__originalClass;
  
  // 元の位置に正確に戻す
  if (videoEl.__originalNextSibling) {
    videoEl.__originalParent.insertBefore(videoEl, videoEl.__originalNextSibling);
  } else {
    videoEl.__originalParent.appendChild(videoEl);
  }
  
  videoEl.onclick = null; // クリックイベントを削除
  
  // 閉じるボタンを削除
  if (videoEl.__closeBtn) {
    videoEl.__closeBtn.remove();
    delete videoEl.__closeBtn;
  }
  
  // 保存した参照をクリーンアップ
  delete videoEl.__originalNextSibling;
  
  enlargedVideo.value = null;
};

// ESCキーで縮小（追加）
const handleKeydown = (e) => {
  if (e.key === 'Escape' && enlargedVideo.value) {
    shrinkVideo();
  }
};

// ルーム参加
const joinRoom = async () => {
  if (joining.value || joined.value || leaving.value) return; // Leaving 中は不可（追加）
  if (!roomId.value) {
    toast.error('ルームIDが設定されていません');
    return;
  }
  // DEBUG: 開始ログ
  console.log('[JOIN] START', {
    roomId: roomId.value,
    roomCreated: roomCreated.value,
    joined: joined.value,
    joining: joining.value,
    leaving: leaving.value
  });

  try {
    joining.value = true;

    // まだルームが作成されていない場合は作る
    if (!roomCreated.value || !context.room) { // room を破棄するので null チェック追加
      await createRoom();
      console.log('[JOIN] createRoom 完了', {
        roomId: context.room?.id,
        publications: context.room?.publications?.length
      });
    }

    // join
    const member = await context.room.join({ name: uuidV4() });
    localMember.value = member;
    console.log('[JOIN] joined', {
      localMemberId: member.id,
      roomMembers: context.room.members.map(m => m.id)
    });

    // ローカルカメラ映像 (音声含めたければ別メソッドも可)
    const videoStream = await SkyWayStreamFactory.createCameraVideoStream();
    // ローカルの映像・音声ストリームを作成して publish（重要）
    const audioStream = await SkyWayStreamFactory.createMicrophoneAudioStream();
    // 退出時に解放するため保持（追加）
    localVideoStream.value = videoStream;
    localAudioStream.value = audioStream;

    // publish と Publication を保持（戻り値を受け取る）
    const videoPub = await member.publish(videoStream);
    const audioPub = await member.publish(audioStream);
    localVideoPublication.value = videoPub;
    localAudioPublication.value = audioPub;
    console.log('[JOIN] publish 完了', {
      videoPubId: videoPub.id,
      audioPubId: audioPub.id
    });

    // デバッグ出力（Join 後に Console で確認しやすくする）
    console.log('LocalVideoPublication:', localVideoPublication.value);
    console.log('LocalAudioPublication:', localAudioPublication.value);
    try {
      window.__localVideoPublication = localVideoPublication.value;
      window.__localAudioPublication = localAudioPublication.value;
    } catch (e) {}

    // ローカル video 要素
    // ローカル映像用コンテナ（追加）
    const localContainer = document.createElement('div');
    localContainer.className = 'relative inline-block';
    streamArea.value.appendChild(localContainer);

    const localVideoEl = document.createElement('video');
    localVideoEl.muted = true;
    localVideoEl.playsInline = true;
    localVideoEl.autoplay = true;
    localVideoEl.className = 'w-96 h-72 object-cover rounded border';
    localContainer.appendChild(localVideoEl);

    // ローカル映像用拡大ボタン（追加）
    const localEnlargeBtn = document.createElement('button');
    localEnlargeBtn.innerHTML = '⛶';
    localEnlargeBtn.className = 'absolute top-2 right-2 bg-black bg-opacity-50 text-white p-1 rounded hover:bg-opacity-70 text-sm';
    localEnlargeBtn.onclick = () => enlargeVideo(localVideoEl);
    localContainer.appendChild(localEnlargeBtn);

    // SkyWay の stream を video に接続
    videoStream.attach(localVideoEl);
    // 退出時に解放するため保持（追加）
    localVideoEl.value = localVideoEl;
    console.log('[JOIN] ローカル video 要素 attach 完了');

    // 追加: 既に公開済みの publication にも一度だけ subscribe（自分のは除外）
    try {
      const pubs = context.room.publications ?? [];
      console.log('[JOIN] 既存 publication 数:', pubs.length);
      for (const pub of pubs) {
        if (pub.publisher.id === member.id) continue;
        if (subscribedPublicationIds.has(pub.id)) continue;
        const { stream } = await member.subscribe(pub.id);
        subscribedPublicationIds.add(pub.id);
        // attachRemoteStream(stream);
        attachRemoteStream(stream, pub);
        console.log('[JOIN] 既存 pub subscribe', pub.id);
      }
    } catch (err) {
      console.warn('subscribe existing pubs failed:', err);
    }

    // 以後新規公開にもsubscribe（重要）
    // 追加: ハンドラを保持して退出時に解除、重複subscribe防止
    roomEventHandlers.onStreamPublished = async (e) => {
      // DEBUG: 発火ログ（publisher / localMember / pubId を全て表示）
      console.log('[EVENT] onStreamPublished', {
        pubId: e.publication.id,
        publisherId: e.publication.publisher.id,
        localMemberId: member.id,
        isLocalById: e.publication.publisher.id === member.id
      });

      // NOTE: 自分の publication を確実に除外（ID / publisher 両面）
      if (
        e.publication.publisher.id === member.id ||
        (localVideoPublication.value && e.publication.id === localVideoPublication.value.id) ||
        (localAudioPublication.value && e.publication.id === localAudioPublication.value.id)
      ) {
        console.log('[EVENT] 自分の publication のため subscribe スキップ', e.publication.id);
        return;
      }

      if (subscribedPublicationIds.has(e.publication.id)) {
        console.log('[EVENT] duplicate skip', e.publication.id);
        return;
      }
      try {
        const { stream } = await member.subscribe(e.publication.id);
        subscribedPublicationIds.add(e.publication.id);
        console.log('[EVENT] 新規 pub subscribe', e.publication.id);
        // attachRemoteStream(stream);
        attachRemoteStream(stream, e.publication);
      } catch (err) {
        console.warn('subscribe new pub failed:', err);
      }
    };
    context.room.onStreamPublished.add(roomEventHandlers.onStreamPublished);
    console.log('[JOIN] onStreamPublished ハンドラ登録');
    // 最小追加: unpublish イベントで DOM を削除
    context.room.onStreamUnpublished.add((e) => {
    const pubId = e.publication.id;
    const el = streamArea.value?.querySelector(`[data-pub-id="${pubId}"]`);
    if (el) {
      el.remove();
      console.log('[EVENT] unpublish -> remove DOM', pubId);
      // remoteVideos 配列からも取り除く（厳密さを保つ）
      remoteVideos.value = remoteVideos.value.filter(v => v !== el);
      // もし Set に記録しているなら削除（任意）
      subscribedPublicationIds.delete(pubId);
      console.log('[EVENT] removed remote element (unpublish)', pubId);
    } else {
      console.log('[EVENT] unpublish but no element found', pubId);
    }
  });
    joined.value = true;

    console.log('[JOIN] SUCCESS 状態', {
      Joined: joined.value,
      LocalMemberId: localMember.value?.id,
      RemoteVideoDomCount: remoteVideos.value.length,
      subscribedPublicationIds: [...subscribedPublicationIds]
    });
  } catch (e) {
    toast.error('ルーム参加に失敗しました: ' + e);
    console.error(e);
  } finally {
    joining.value = false;
  }
};

// 退出（Leave）
const leaveRoom = async () => {
  if (leaving.value) return; // 二重押下防止（追加）
  leaving.value = true;
  // DEBUG: 開始時のメンバー一覧（取得できる範囲）
  console.log('[LEAVE] START', {
    Joined: joined.value,
    LocalMemberId: localMember.value?.id,
    roomMembersSnapshot: context.room?.members?.map(m => m.id)
  });
  try {
    // まず leave を試す（先に leave することでゴーストメンバー化を防止）
    let leaveSucceeded = false;
    if (localMember.value?.leave) {
      try {
        await localMember.value.leave();
        leaveSucceeded = true;
        console.log('[LEAVE] member.leave() 完了');
      } catch (err) {
        console.warn('[LEAVE] member.leave() 失敗 -> フォールバックで unpublish', err);
      }
    } else {
      console.log('[LEAVE] member.leave() 不可 (メソッドなし)');
    }

    // leave が失敗した場合のみ unpublish を試す（成功していれば不要）
    if (!leaveSucceeded && localMember.value?.unpublish) {
      try {
        if (localVideoPublication.value) {
          await localMember.value.unpublish(localVideoPublication.value);
          console.log('[LEAVE][FB] unpublish video', localVideoPublication.value.id);
        }
        if (localAudioPublication.value) {
          await localMember.value.unpublish(localAudioPublication.value);
          console.log('[LEAVE][FB] unpublish audio', localAudioPublication.value.id);
        }
      } catch (e) {
        console.warn('[LEAVE][FB] unpublish failed', e);
      }
    }

    // 追加: 新規配信イベントのハンドラを解除（多重登録/二重subscribe防止）
    if (context.room && roomEventHandlers.onStreamPublished && typeof context.room.onStreamPublished?.remove === 'function') {
      try { 
        context.room.onStreamPublished.remove(roomEventHandlers.onStreamPublished); 
        console.log('[LEAVE] onStreamPublished ハンドラ解除');
      } catch (e) {
        console.warn('[LEAVE] handler remove failed', e);
      }
    }
    roomEventHandlers.onStreamPublished = null;

    // ローカルメディアの解放
    if (localVideoStream.value) {
      try {
        localVideoStream.value.detach?.();
        localVideoStream.value.track?.stop?.();
        console.log('[LEAVE] local video track stopped');
      } catch {}
    }
    if (localAudioStream.value) {
      try {
        localAudioStream.value.detach?.();
        localAudioStream.value.track?.stop?.();
        console.log('[LEAVE] local audio track stopped');
      } catch {}
    }

    // ローカル要素の削除
    if (localVideoEl.value && localVideoEl.value.parentNode) {
      localVideoEl.value.pause?.();
      localVideoEl.value.srcObject = null;
      localVideoEl.value.parentNode.removeChild(localVideoEl.value);
      console.log('[LEAVE] local video element removed');
    }
    localVideoEl.value = null;

    // リモート要素の削除
    const removing = remoteVideos.value.length;
    for (const el of remoteVideos.value) {
      try {
        el.pause?.();
        el.srcObject = null;
        el.remove();
      } catch {}
    }
    remoteVideos.value = [];
    console.log('[LEAVE] remote elements removed', removing);

    // 追加: 映像拡大中なら縮小してオーバーレイを除去
    if (enlargedVideo.value) {
      try { shrinkVideo(); console.log('[LEAVE] shrinkVideo 実行'); } catch {}
    }

    // 追加: 念のため表示領域を完全クリア（取りこぼし対策）
    if (streamArea.value) {
      try { streamArea.value.innerHTML = ''; console.log('[LEAVE] StreamArea cleared'); } catch {}
    }

    // 状態初期化（RoomIdは残す＝再参加しやすくする）
    joined.value = false;
    joining.value = false;
    localMember.value = null;
    localVideoStream.value = null;
    localAudioStream.value = null;

    // ミュート状態初期化（新規追加）
    isAudioMuted.value = false;
    isVideoMuted.value = false;
    isScreenSharing.value = false; // 追加: 画面共有の状態も戻す

    // 追加: Publication 参照をリセット
    localVideoPublication.value = null;
    localAudioPublication.value = null;

    // 追加: subscribe 済み publication の記録をクリア
    subscribedPublicationIds.clear();
    console.log('[LEAVE] subscribedPublicationIds cleared');

    // NOTE: room インスタンスを null にする前に（デバッグ用に）メンバー確認
    console.log('[LEAVE] room.members snapshot (before null)', context.room?.members?.map(m => m.id));

    // 重要: 同じ Room インスタンスでの再 join を避けるため破棄（追加）
    roomCreated.value = false;
    context.room = null;

    // DEBUG: 終了ログ
    console.log('[LEAVE] END', {
      Joined: joined.value,
      LocalMember: localMember.value,
      RoomCreated: roomCreated.value,
      RemoteVideoDomCount: remoteVideos.value.length
    });
  } catch (e) {
    console.error('leave failed:', e);
  } finally {
    leaving.value = false;
  }
};
// onMounted: URL に room=xxx があれば利用
onMounted(async () => {
  await getContext();
  const qRoom = new URLSearchParams(window.location.search).get('room');
  if (qRoom) {
    roomId.value = qRoom;
  }
  // ESCキーリスナー追加
  document.addEventListener('keydown', handleKeydown);
});

// クリーンアップ（追加）
onUnmounted(() => {
  document.removeEventListener('keydown', handleKeydown);
});
</script>

<template>
  <div class="p-4 space-y-6">
        <!-- 拡大表示中の縮小用オーバーレイ（追加） -->
    <div 
      v-if="enlargedVideo" 
      @click="shrinkVideo"
      class="fixed inset-0 bg-transparent z-40 cursor-pointer"
      title="クリックして元のサイズに戻す"
    ></div>

    <h1 class="text-2xl font-bold">会議</h1>

    <div class="flex gap-4 flex-wrap">
      <!-- ボタンエリア -->
      <div class="space-x-2">
        <button
          v-if="!roomCreated"
          @click="createRoom"
          class="inline-flex items-center px-4 py-2 rounded bg-blue-600 text-white font-medium hover:bg-blue-700 active:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-400"
        >
          ルーム作成
        </button>

        <button
          v-if="roomId && !joined"
          :disabled="joining || leaving"  
          @click="joinRoom"
          class="inline-flex items-center px-4 py-2 rounded bg-green-600 text-white font-medium hover:bg-green-700 active:bg-green-800 focus:outline-none focus:ring-2 focus:ring-green-400 disabled:opacity-50"
        >
          {{ joining ? 'Joining...' : 'ルーム参加' }}
        </button>

         <button
          v-if="joined"
          :disabled="leaving"            
          @click="leaveRoom"
          class="inline-flex items-center px-4 py-2 rounded bg-gray-600 text-white font-medium hover:bg-gray-700 active:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-400 disabled:opacity-50"
        >
          {{ leaving ? 'Leaving...' : 'ルーム退出' }}
        </button>
      </div>

      <div v-if="errorMessage" class="text-sm text-red-600 font-medium">
        {{ errorMessage }}
      </div>
    </div>

     <!-- ミュートボタン（新規追加） -->
      <div v-if="joined" class="space-x-2">
        <!-- 音声ミュートボタン -->
        <button
          @click="toggleAudioMute"
          :class="[
            'inline-flex items-center px-4 py-2 rounded font-medium focus:outline-none focus:ring-2',
            isAudioMuted 
              ? 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-400' 
              : 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-400'
          ]"
        >
          {{ isAudioMuted ? '🔇 ミュート中' : '🎤 音声ON' }}
        </button>

        <!-- 映像ミュートボタン -->
        <button
          @click="toggleVideoMute"
          :class="[
            'inline-flex items-center px-4 py-2 rounded font-medium focus:outline-none focus:ring-2',
            isVideoMuted 
              ? 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-400' 
              : 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-400'
          ]"
        >
          {{ isVideoMuted ? '📹 映像OFF' : '📹 映像ON' }}
        </button>
        <!--画面共有ボタン-->
        <button
          @click="screenShare"
          :class="[
            'inline-flex items-center px-4 py-2 rounded font-medium focus:outline-none focus:ring-2',
            isScreenSharing
              ? 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-400'
              : 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-400'
          ]"
        >
          {{ isScreenSharing ? '🖥️ 画面共有中' : '🖥️ 画面共有' }}
        </button>
      </div>

    <!-- ルーム情報表示 -->
    <div v-if="roomId" class="space-y-2 text-sm">
      <p>以下のURLを相手と共有:</p>
      <p class="break-all font-mono bg-gray-100 px-2 py-1 rounded">
        {{ baseUrl }}?room={{ roomId }}
      </p>
      <p>またはルームID:</p>
      <p class="font-mono bg-gray-100 px-2 py-1 inline-block rounded">{{ roomId }}</p>
    </div>

    <!-- 映像表示エリア -->
    <div
      ref="streamArea"
      v-if="roomCreated"
      class="flex gap-4 flex-wrap border rounded p-3 min-h-[200px]"
    ></div>

    <div v-else class="text-gray-500 italic">
      まだルームは作成されていません。
    </div>
  </div>
</template>
